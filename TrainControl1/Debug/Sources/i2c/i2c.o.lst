   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"i2c.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.i2cStart,"ax",%progbits
  18              		.align	1
  19              		.global	i2cStart
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	i2cStart:
  26              	.LFB125:
  27              		.file 1 "../Sources/i2c/i2c.c"
   1:../Sources/i2c/i2c.c **** /**
   2:../Sources/i2c/i2c.c ****  *--------------------------------------------------------------------\n
   3:../Sources/i2c/i2c.c ****  *          HSLU T&A Hochschule Luzern Technik+Architektur            \n
   4:../Sources/i2c/i2c.c ****  *--------------------------------------------------------------------\n
   5:../Sources/i2c/i2c.c ****  *
   6:../Sources/i2c/i2c.c ****  * \brief         i2c driver
   7:../Sources/i2c/i2c.c ****  * \file
   8:../Sources/i2c/i2c.c ****  * \author        Christian Jost, christian.jost@hslu.ch
   9:../Sources/i2c/i2c.c ****  * \date          24.04.20018
  10:../Sources/i2c/i2c.c ****  *
  11:../Sources/i2c/i2c.c ****  * $Id: i2c.c 102 2018-05-01 14:06:17Z zajost $
  12:../Sources/i2c/i2c.c ****  *
  13:../Sources/i2c/i2c.c ****  *--------------------------------------------------------------------
  14:../Sources/i2c/i2c.c ****  */
  15:../Sources/i2c/i2c.c **** #include "platform.h"
  16:../Sources/i2c/i2c.c **** #include "i2c.h"
  17:../Sources/i2c/i2c.c **** 
  18:../Sources/i2c/i2c.c **** 
  19:../Sources/i2c/i2c.c **** #define I2Cx_F                  (I2C0_F)
  20:../Sources/i2c/i2c.c **** #define I2Cx_C1                 (I2C0_C1)
  21:../Sources/i2c/i2c.c **** #define I2Cx_S                  (I2C0_S)
  22:../Sources/i2c/i2c.c **** #define I2Cx_D                  (I2C0_D)
  23:../Sources/i2c/i2c.c **** 
  24:../Sources/i2c/i2c.c **** 
  25:../Sources/i2c/i2c.c **** //-------------------------------------------------------------------------------------------------
  26:../Sources/i2c/i2c.c **** // I 2 C   -   B A S E   F U N C T I O N S
  27:../Sources/i2c/i2c.c **** //-------------------------------------------------------------------------------------------------
  28:../Sources/i2c/i2c.c **** 
  29:../Sources/i2c/i2c.c **** /**
  30:../Sources/i2c/i2c.c ****  * Generates a start condition on the I2C-Bus
  31:../Sources/i2c/i2c.c ****  *
  32:../Sources/i2c/i2c.c ****  * @param [in] adr
  33:../Sources/i2c/i2c.c ****  *   the slave address
  34:../Sources/i2c/i2c.c ****  * @param [in] read
  35:../Sources/i2c/i2c.c ****  *   FALSE => write
  36:../Sources/i2c/i2c.c ****  *   TRUE => read
  37:../Sources/i2c/i2c.c ****  * @return
  38:../Sources/i2c/i2c.c ****  *   EC_SUCCESS       the slave answered with an ACK
  39:../Sources/i2c/i2c.c ****  *   C_I2C_NO_ANSWER  no answer from a slave
  40:../Sources/i2c/i2c.c ****  */
  41:../Sources/i2c/i2c.c **** tError i2cStart(uint8_t adr, bool read)
  42:../Sources/i2c/i2c.c **** {
  28              		.loc 1 42 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33 0000 80B4     		push	{r7}
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 7, -4
  36 0002 83B0     		sub	sp, sp, #12
  37              		.cfi_def_cfa_offset 16
  38 0004 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  40 0006 0346     		mov	r3, r0
  41 0008 0A46     		mov	r2, r1
  42 000a FB71     		strb	r3, [r7, #7]
  43 000c 1346     		mov	r3, r2
  44 000e BB71     		strb	r3, [r7, #6]
  43:../Sources/i2c/i2c.c ****     adr = (uint8_t)adr << 1;                // combine address with r/w bit
  45              		.loc 1 43 0
  46 0010 FB79     		ldrb	r3, [r7, #7]
  47 0012 5B00     		lsls	r3, r3, #1
  48 0014 FB71     		strb	r3, [r7, #7]
  44:../Sources/i2c/i2c.c ****     adr |= read;                            // add r/w bit
  49              		.loc 1 44 0
  50 0016 97F90720 		ldrsb	r2, [r7, #7]
  51 001a BB79     		ldrb	r3, [r7, #6]
  52 001c 1343     		orrs	r3, r3, r2
  53 001e 5BB2     		sxtb	r3, r3
  54 0020 FB71     		strb	r3, [r7, #7]
  45:../Sources/i2c/i2c.c **** 
  46:../Sources/i2c/i2c.c ****     while (I2Cx_S & I2C_S_BUSY_MASK);       // wait until i2c bus is idle. Necessary if two transmi
  55              		.loc 1 46 0
  56 0022 00BF     		nop
  57              	.L2:
  58              		.loc 1 46 0 is_stmt 0 discriminator 1
  59 0024 244B     		ldr	r3, .L6
  60 0026 DB78     		ldrb	r3, [r3, #3]
  61 0028 DBB2     		uxtb	r3, r3
  62 002a 03F02003 		and	r3, r3, #32
  63 002e 002B     		cmp	r3, #0
  64 0030 F8D1     		bne	.L2
  47:../Sources/i2c/i2c.c **** 
  48:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
  65              		.loc 1 48 0 is_stmt 1
  66 0032 214A     		ldr	r2, .L6
  67 0034 204B     		ldr	r3, .L6
  68 0036 DB78     		ldrb	r3, [r3, #3]
  69 0038 DBB2     		uxtb	r3, r3
  70 003a 43F00203 		orr	r3, r3, #2
  71 003e DBB2     		uxtb	r3, r3
  72 0040 D370     		strb	r3, [r2, #3]
  49:../Sources/i2c/i2c.c ****     I2Cx_C1 |= I2C_C1_TX_MASK;              // change to transmit mode
  73              		.loc 1 49 0
  74 0042 1D4A     		ldr	r2, .L6
  75 0044 1C4B     		ldr	r3, .L6
  76 0046 9B78     		ldrb	r3, [r3, #2]
  77 0048 DBB2     		uxtb	r3, r3
  78 004a 43F01003 		orr	r3, r3, #16
  79 004e DBB2     		uxtb	r3, r3
  80 0050 9370     		strb	r3, [r2, #2]
  50:../Sources/i2c/i2c.c ****     I2Cx_C1 |= I2C_C1_MST_MASK;             // generate the start-condition
  81              		.loc 1 50 0
  82 0052 194A     		ldr	r2, .L6
  83 0054 184B     		ldr	r3, .L6
  84 0056 9B78     		ldrb	r3, [r3, #2]
  85 0058 DBB2     		uxtb	r3, r3
  86 005a 43F02003 		orr	r3, r3, #32
  87 005e DBB2     		uxtb	r3, r3
  88 0060 9370     		strb	r3, [r2, #2]
  51:../Sources/i2c/i2c.c ****     I2Cx_D = adr;                           // send address with r/w bit
  89              		.loc 1 51 0
  90 0062 154A     		ldr	r2, .L6
  91 0064 FB79     		ldrb	r3, [r7, #7]
  92 0066 1371     		strb	r3, [r2, #4]
  52:../Sources/i2c/i2c.c ****     while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
  93              		.loc 1 52 0
  94 0068 00BF     		nop
  95              	.L3:
  96              		.loc 1 52 0 is_stmt 0 discriminator 1
  97 006a 134B     		ldr	r3, .L6
  98 006c DB78     		ldrb	r3, [r3, #3]
  99 006e DBB2     		uxtb	r3, r3
 100 0070 03F00203 		and	r3, r3, #2
 101 0074 002B     		cmp	r3, #0
 102 0076 F8D0     		beq	.L3
  53:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 103              		.loc 1 53 0 is_stmt 1
 104 0078 0F4A     		ldr	r2, .L6
 105 007a 0F4B     		ldr	r3, .L6
 106 007c DB78     		ldrb	r3, [r3, #3]
 107 007e DBB2     		uxtb	r3, r3
 108 0080 43F00203 		orr	r3, r3, #2
 109 0084 DBB2     		uxtb	r3, r3
 110 0086 D370     		strb	r3, [r2, #3]
  54:../Sources/i2c/i2c.c **** 
  55:../Sources/i2c/i2c.c ****     if (I2Cx_S & I2C_S_RXAK_MASK) {         // Check if an ACK has been received
 111              		.loc 1 55 0
 112 0088 0B4B     		ldr	r3, .L6
 113 008a DB78     		ldrb	r3, [r3, #3]
 114 008c DBB2     		uxtb	r3, r3
 115 008e 03F00103 		and	r3, r3, #1
 116 0092 002B     		cmp	r3, #0
 117 0094 09D0     		beq	.L4
  56:../Sources/i2c/i2c.c ****         I2Cx_C1 &= ~I2C_C1_MST_MASK;        // generate Stop-Condition
 118              		.loc 1 56 0
 119 0096 084A     		ldr	r2, .L6
 120 0098 074B     		ldr	r3, .L6
 121 009a 9B78     		ldrb	r3, [r3, #2]
 122 009c DBB2     		uxtb	r3, r3
 123 009e 23F02003 		bic	r3, r3, #32
 124 00a2 DBB2     		uxtb	r3, r3
 125 00a4 9370     		strb	r3, [r2, #2]
  57:../Sources/i2c/i2c.c ****         return EC_I2C_NO_ANSWER;            // NAK => abort
 126              		.loc 1 57 0
 127 00a6 0523     		movs	r3, #5
 128 00a8 00E0     		b	.L5
 129              	.L4:
  58:../Sources/i2c/i2c.c ****     }
  59:../Sources/i2c/i2c.c ****     return EC_SUCCESS;
 130              		.loc 1 59 0
 131 00aa 0023     		movs	r3, #0
 132              	.L5:
  60:../Sources/i2c/i2c.c **** }
 133              		.loc 1 60 0
 134 00ac 1846     		mov	r0, r3
 135 00ae 0C37     		adds	r7, r7, #12
 136              		.cfi_def_cfa_offset 4
 137 00b0 BD46     		mov	sp, r7
 138              		.cfi_def_cfa_register 13
 139              		@ sp needed
 140 00b2 5DF8047B 		ldr	r7, [sp], #4
 141              		.cfi_restore 7
 142              		.cfi_def_cfa_offset 0
 143 00b6 7047     		bx	lr
 144              	.L7:
 145              		.align	2
 146              	.L6:
 147 00b8 00600640 		.word	1074159616
 148              		.cfi_endproc
 149              	.LFE125:
 151              		.section	.text.i2cRepeatedStart,"ax",%progbits
 152              		.align	1
 153              		.global	i2cRepeatedStart
 154              		.syntax unified
 155              		.thumb
 156              		.thumb_func
 157              		.fpu fpv4-sp-d16
 159              	i2cRepeatedStart:
 160              	.LFB126:
  61:../Sources/i2c/i2c.c **** 
  62:../Sources/i2c/i2c.c **** /**
  63:../Sources/i2c/i2c.c ****  * Generates a repeated start condition on the I2C-Bus
  64:../Sources/i2c/i2c.c ****  *
  65:../Sources/i2c/i2c.c ****  * @param [in] adr
  66:../Sources/i2c/i2c.c ****  *   the slave address (7bit)
  67:../Sources/i2c/i2c.c ****  * @param [in] read
  68:../Sources/i2c/i2c.c ****  *   FALSE => write mode
  69:../Sources/i2c/i2c.c ****  *   TRUE =>  read mode
  70:../Sources/i2c/i2c.c ****  * @return
  71:../Sources/i2c/i2c.c ****  *    EC_SUCCESS        if the slave answered with an ACK
  72:../Sources/i2c/i2c.c ****  *    EC_I2C_NO_ANSWER  no answer from a slave
  73:../Sources/i2c/i2c.c ****  */
  74:../Sources/i2c/i2c.c **** tError i2cRepeatedStart(uint8_t adr, bool read)
  75:../Sources/i2c/i2c.c **** {
 161              		.loc 1 75 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 8
 164              		@ frame_needed = 1, uses_anonymous_args = 0
 165              		@ link register save eliminated.
 166 0000 80B4     		push	{r7}
 167              		.cfi_def_cfa_offset 4
 168              		.cfi_offset 7, -4
 169 0002 83B0     		sub	sp, sp, #12
 170              		.cfi_def_cfa_offset 16
 171 0004 00AF     		add	r7, sp, #0
 172              		.cfi_def_cfa_register 7
 173 0006 0346     		mov	r3, r0
 174 0008 0A46     		mov	r2, r1
 175 000a FB71     		strb	r3, [r7, #7]
 176 000c 1346     		mov	r3, r2
 177 000e BB71     		strb	r3, [r7, #6]
  76:../Sources/i2c/i2c.c ****   adr = (uint8_t)adr << 1;
 178              		.loc 1 76 0
 179 0010 FB79     		ldrb	r3, [r7, #7]
 180 0012 5B00     		lsls	r3, r3, #1
 181 0014 FB71     		strb	r3, [r7, #7]
  77:../Sources/i2c/i2c.c ****   adr |= read;
 182              		.loc 1 77 0
 183 0016 97F90720 		ldrsb	r2, [r7, #7]
 184 001a BB79     		ldrb	r3, [r7, #6]
 185 001c 1343     		orrs	r3, r3, r2
 186 001e 5BB2     		sxtb	r3, r3
 187 0020 FB71     		strb	r3, [r7, #7]
  78:../Sources/i2c/i2c.c **** 
  79:../Sources/i2c/i2c.c ****   I2Cx_C1 |= I2C_C1_RSTA_MASK;              // generate a repeated start condition
 188              		.loc 1 79 0
 189 0022 194A     		ldr	r2, .L12
 190 0024 184B     		ldr	r3, .L12
 191 0026 9B78     		ldrb	r3, [r3, #2]
 192 0028 DBB2     		uxtb	r3, r3
 193 002a 43F00403 		orr	r3, r3, #4
 194 002e DBB2     		uxtb	r3, r3
 195 0030 9370     		strb	r3, [r2, #2]
  80:../Sources/i2c/i2c.c **** 
  81:../Sources/i2c/i2c.c ****   I2Cx_D = adr;                             // sends the address with the read/write bit
 196              		.loc 1 81 0
 197 0032 154A     		ldr	r2, .L12
 198 0034 FB79     		ldrb	r3, [r7, #7]
 199 0036 1371     		strb	r3, [r2, #4]
  82:../Sources/i2c/i2c.c ****   while (!(I2Cx_S & I2C_S_IICIF_MASK));     // wait for the transfer to complete
 200              		.loc 1 82 0
 201 0038 00BF     		nop
 202              	.L9:
 203              		.loc 1 82 0 is_stmt 0 discriminator 1
 204 003a 134B     		ldr	r3, .L12
 205 003c DB78     		ldrb	r3, [r3, #3]
 206 003e DBB2     		uxtb	r3, r3
 207 0040 03F00203 		and	r3, r3, #2
 208 0044 002B     		cmp	r3, #0
 209 0046 F8D0     		beq	.L9
  83:../Sources/i2c/i2c.c ****   I2Cx_S |= I2C_S_IICIF_MASK;               // clear the interrupt flag
 210              		.loc 1 83 0 is_stmt 1
 211 0048 0F4A     		ldr	r2, .L12
 212 004a 0F4B     		ldr	r3, .L12
 213 004c DB78     		ldrb	r3, [r3, #3]
 214 004e DBB2     		uxtb	r3, r3
 215 0050 43F00203 		orr	r3, r3, #2
 216 0054 DBB2     		uxtb	r3, r3
 217 0056 D370     		strb	r3, [r2, #3]
  84:../Sources/i2c/i2c.c **** 
  85:../Sources/i2c/i2c.c ****   if (I2Cx_S & I2C_S_RXAK_MASK) {           // Check if an ACK has been received
 218              		.loc 1 85 0
 219 0058 0B4B     		ldr	r3, .L12
 220 005a DB78     		ldrb	r3, [r3, #3]
 221 005c DBB2     		uxtb	r3, r3
 222 005e 03F00103 		and	r3, r3, #1
 223 0062 002B     		cmp	r3, #0
 224 0064 09D0     		beq	.L10
  86:../Sources/i2c/i2c.c ****     I2Cx_C1 &= ~I2C_C1_MST_MASK;            // generate Stop-Condition
 225              		.loc 1 86 0
 226 0066 084A     		ldr	r2, .L12
 227 0068 074B     		ldr	r3, .L12
 228 006a 9B78     		ldrb	r3, [r3, #2]
 229 006c DBB2     		uxtb	r3, r3
 230 006e 23F02003 		bic	r3, r3, #32
 231 0072 DBB2     		uxtb	r3, r3
 232 0074 9370     		strb	r3, [r2, #2]
  87:../Sources/i2c/i2c.c ****     return EC_I2C_NO_ANSWER;                // NAK => abort
 233              		.loc 1 87 0
 234 0076 0523     		movs	r3, #5
 235 0078 00E0     		b	.L11
 236              	.L10:
  88:../Sources/i2c/i2c.c ****   }
  89:../Sources/i2c/i2c.c ****   return EC_SUCCESS;
 237              		.loc 1 89 0
 238 007a 0023     		movs	r3, #0
 239              	.L11:
  90:../Sources/i2c/i2c.c **** }
 240              		.loc 1 90 0
 241 007c 1846     		mov	r0, r3
 242 007e 0C37     		adds	r7, r7, #12
 243              		.cfi_def_cfa_offset 4
 244 0080 BD46     		mov	sp, r7
 245              		.cfi_def_cfa_register 13
 246              		@ sp needed
 247 0082 5DF8047B 		ldr	r7, [sp], #4
 248              		.cfi_restore 7
 249              		.cfi_def_cfa_offset 0
 250 0086 7047     		bx	lr
 251              	.L13:
 252              		.align	2
 253              	.L12:
 254 0088 00600640 		.word	1074159616
 255              		.cfi_endproc
 256              	.LFE126:
 258              		.section	.text.i2cReceiveLastByte,"ax",%progbits
 259              		.align	1
 260              		.global	i2cReceiveLastByte
 261              		.syntax unified
 262              		.thumb
 263              		.thumb_func
 264              		.fpu fpv4-sp-d16
 266              	i2cReceiveLastByte:
 267              	.LFB127:
  91:../Sources/i2c/i2c.c **** 
  92:../Sources/i2c/i2c.c **** /**
  93:../Sources/i2c/i2c.c ****  * Receives the last byte from a slave
  94:../Sources/i2c/i2c.c ****  *
  95:../Sources/i2c/i2c.c ****  * For the last byte don't send an ACK to generate
  96:../Sources/i2c/i2c.c ****  * the stop condition after
  97:../Sources/i2c/i2c.c ****  *
  98:../Sources/i2c/i2c.c ****  * @return
  99:../Sources/i2c/i2c.c ****  *  the received byte
 100:../Sources/i2c/i2c.c ****  */
 101:../Sources/i2c/i2c.c **** uint8_t i2cReceiveLastByte(void)
 102:../Sources/i2c/i2c.c **** {
 268              		.loc 1 102 0
 269              		.cfi_startproc
 270              		@ args = 0, pretend = 0, frame = 8
 271              		@ frame_needed = 1, uses_anonymous_args = 0
 272              		@ link register save eliminated.
 273 0000 80B4     		push	{r7}
 274              		.cfi_def_cfa_offset 4
 275              		.cfi_offset 7, -4
 276 0002 83B0     		sub	sp, sp, #12
 277              		.cfi_def_cfa_offset 16
 278 0004 00AF     		add	r7, sp, #0
 279              		.cfi_def_cfa_register 7
 103:../Sources/i2c/i2c.c ****   uint8_t data;
 104:../Sources/i2c/i2c.c ****   I2Cx_C1 &= ~I2C_C1_TX_MASK;               // change to receive mode
 280              		.loc 1 104 0
 281 0006 1A4A     		ldr	r2, .L17
 282 0008 194B     		ldr	r3, .L17
 283 000a 9B78     		ldrb	r3, [r3, #2]
 284 000c DBB2     		uxtb	r3, r3
 285 000e 23F01003 		bic	r3, r3, #16
 286 0012 DBB2     		uxtb	r3, r3
 287 0014 9370     		strb	r3, [r2, #2]
 105:../Sources/i2c/i2c.c ****   I2Cx_C1 |= I2C_C1_TXAK_MASK;              // Don't send an ACK after the last byte received to ge
 288              		.loc 1 105 0
 289 0016 164A     		ldr	r2, .L17
 290 0018 154B     		ldr	r3, .L17
 291 001a 9B78     		ldrb	r3, [r3, #2]
 292 001c DBB2     		uxtb	r3, r3
 293 001e 43F00803 		orr	r3, r3, #8
 294 0022 DBB2     		uxtb	r3, r3
 295 0024 9370     		strb	r3, [r2, #2]
 106:../Sources/i2c/i2c.c **** 
 107:../Sources/i2c/i2c.c ****   data = I2Cx_D;                            // dummy read to start the last transmission to read th
 296              		.loc 1 107 0
 297 0026 124B     		ldr	r3, .L17
 298 0028 1B79     		ldrb	r3, [r3, #4]
 299 002a FB71     		strb	r3, [r7, #7]
 108:../Sources/i2c/i2c.c **** 
 109:../Sources/i2c/i2c.c ****   while (!(I2Cx_S & I2C_S_IICIF_MASK));     // wait for the transfer to complete
 300              		.loc 1 109 0
 301 002c 00BF     		nop
 302              	.L15:
 303              		.loc 1 109 0 is_stmt 0 discriminator 1
 304 002e 104B     		ldr	r3, .L17
 305 0030 DB78     		ldrb	r3, [r3, #3]
 306 0032 DBB2     		uxtb	r3, r3
 307 0034 03F00203 		and	r3, r3, #2
 308 0038 002B     		cmp	r3, #0
 309 003a F8D0     		beq	.L15
 110:../Sources/i2c/i2c.c ****   I2Cx_S |= I2C_S_IICIF_MASK;               // clear the interrupt flag
 310              		.loc 1 110 0 is_stmt 1
 311 003c 0C4A     		ldr	r2, .L17
 312 003e 0C4B     		ldr	r3, .L17
 313 0040 DB78     		ldrb	r3, [r3, #3]
 314 0042 DBB2     		uxtb	r3, r3
 315 0044 43F00203 		orr	r3, r3, #2
 316 0048 DBB2     		uxtb	r3, r3
 317 004a D370     		strb	r3, [r2, #3]
 111:../Sources/i2c/i2c.c ****   I2Cx_C1 &= ~I2C_C1_MST_MASK;              // generate Stop-Condition
 318              		.loc 1 111 0
 319 004c 084A     		ldr	r2, .L17
 320 004e 084B     		ldr	r3, .L17
 321 0050 9B78     		ldrb	r3, [r3, #2]
 322 0052 DBB2     		uxtb	r3, r3
 323 0054 23F02003 		bic	r3, r3, #32
 324 0058 DBB2     		uxtb	r3, r3
 325 005a 9370     		strb	r3, [r2, #2]
 112:../Sources/i2c/i2c.c ****   data = I2Cx_D;                            // read last received byte
 326              		.loc 1 112 0
 327 005c 044B     		ldr	r3, .L17
 328 005e 1B79     		ldrb	r3, [r3, #4]
 329 0060 FB71     		strb	r3, [r7, #7]
 113:../Sources/i2c/i2c.c ****   return data;
 330              		.loc 1 113 0
 331 0062 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 114:../Sources/i2c/i2c.c **** }
 332              		.loc 1 114 0
 333 0064 1846     		mov	r0, r3
 334 0066 0C37     		adds	r7, r7, #12
 335              		.cfi_def_cfa_offset 4
 336 0068 BD46     		mov	sp, r7
 337              		.cfi_def_cfa_register 13
 338              		@ sp needed
 339 006a 5DF8047B 		ldr	r7, [sp], #4
 340              		.cfi_restore 7
 341              		.cfi_def_cfa_offset 0
 342 006e 7047     		bx	lr
 343              	.L18:
 344              		.align	2
 345              	.L17:
 346 0070 00600640 		.word	1074159616
 347              		.cfi_endproc
 348              	.LFE127:
 350              		.section	.text.i2cSendData,"ax",%progbits
 351              		.align	1
 352              		.global	i2cSendData
 353              		.syntax unified
 354              		.thumb
 355              		.thumb_func
 356              		.fpu fpv4-sp-d16
 358              	i2cSendData:
 359              	.LFB128:
 115:../Sources/i2c/i2c.c **** 
 116:../Sources/i2c/i2c.c **** /**
 117:../Sources/i2c/i2c.c ****  * Transmitts a buffer. It is assumed that
 118:../Sources/i2c/i2c.c ****  * i2cStart() was successful before.
 119:../Sources/i2c/i2c.c ****  *
 120:../Sources/i2c/i2c.c ****  * @param [in] buf
 121:../Sources/i2c/i2c.c ****  *   the data to send
 122:../Sources/i2c/i2c.c ****  * @param [in] length
 123:../Sources/i2c/i2c.c ****  *   the number of bytes to send
 124:../Sources/i2c/i2c.c ****  *
 125:../Sources/i2c/i2c.c ****  * @return
 126:../Sources/i2c/i2c.c ****  *    EC_SUCCESS if the slave answered with an ACK
 127:../Sources/i2c/i2c.c ****  *    EC_I2C_NAK if the slave answered with a NAK
 128:../Sources/i2c/i2c.c ****  */
 129:../Sources/i2c/i2c.c **** tError i2cSendData(uint8_t *buf, uint8_t length)
 130:../Sources/i2c/i2c.c **** {
 360              		.loc 1 130 0
 361              		.cfi_startproc
 362              		@ args = 0, pretend = 0, frame = 16
 363              		@ frame_needed = 1, uses_anonymous_args = 0
 364              		@ link register save eliminated.
 365 0000 80B4     		push	{r7}
 366              		.cfi_def_cfa_offset 4
 367              		.cfi_offset 7, -4
 368 0002 85B0     		sub	sp, sp, #20
 369              		.cfi_def_cfa_offset 24
 370 0004 00AF     		add	r7, sp, #0
 371              		.cfi_def_cfa_register 7
 372 0006 7860     		str	r0, [r7, #4]
 373 0008 0B46     		mov	r3, r1
 374 000a FB70     		strb	r3, [r7, #3]
 131:../Sources/i2c/i2c.c ****   uint8_t i;
 132:../Sources/i2c/i2c.c ****     for (i=0; i<length; i++)
 375              		.loc 1 132 0
 376 000c 0023     		movs	r3, #0
 377 000e FB73     		strb	r3, [r7, #15]
 378 0010 29E0     		b	.L20
 379              	.L24:
 133:../Sources/i2c/i2c.c ****     {
 134:../Sources/i2c/i2c.c ****         I2Cx_D = buf[i];                        // start the transmission of a databyte
 380              		.loc 1 134 0
 381 0012 1A49     		ldr	r1, .L25
 382 0014 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 383 0016 7A68     		ldr	r2, [r7, #4]
 384 0018 1344     		add	r3, r3, r2
 385 001a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 386 001c 0B71     		strb	r3, [r1, #4]
 135:../Sources/i2c/i2c.c ****         while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
 387              		.loc 1 135 0
 388 001e 00BF     		nop
 389              	.L21:
 390              		.loc 1 135 0 is_stmt 0 discriminator 1
 391 0020 164B     		ldr	r3, .L25
 392 0022 DB78     		ldrb	r3, [r3, #3]
 393 0024 DBB2     		uxtb	r3, r3
 394 0026 03F00203 		and	r3, r3, #2
 395 002a 002B     		cmp	r3, #0
 396 002c F8D0     		beq	.L21
 136:../Sources/i2c/i2c.c ****         I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 397              		.loc 1 136 0 is_stmt 1
 398 002e 134A     		ldr	r2, .L25
 399 0030 124B     		ldr	r3, .L25
 400 0032 DB78     		ldrb	r3, [r3, #3]
 401 0034 DBB2     		uxtb	r3, r3
 402 0036 43F00203 		orr	r3, r3, #2
 403 003a DBB2     		uxtb	r3, r3
 404 003c D370     		strb	r3, [r2, #3]
 137:../Sources/i2c/i2c.c ****         if (I2Cx_S & I2C_S_RXAK_MASK) {         // Check if an ACK has been received
 405              		.loc 1 137 0
 406 003e 0F4B     		ldr	r3, .L25
 407 0040 DB78     		ldrb	r3, [r3, #3]
 408 0042 DBB2     		uxtb	r3, r3
 409 0044 03F00103 		and	r3, r3, #1
 410 0048 002B     		cmp	r3, #0
 411 004a 09D0     		beq	.L22
 138:../Sources/i2c/i2c.c ****             I2Cx_C1 &= ~I2C_C1_MST_MASK;        // generate Stop-Condition
 412              		.loc 1 138 0
 413 004c 0B4A     		ldr	r2, .L25
 414 004e 0B4B     		ldr	r3, .L25
 415 0050 9B78     		ldrb	r3, [r3, #2]
 416 0052 DBB2     		uxtb	r3, r3
 417 0054 23F02003 		bic	r3, r3, #32
 418 0058 DBB2     		uxtb	r3, r3
 419 005a 9370     		strb	r3, [r2, #2]
 139:../Sources/i2c/i2c.c ****             return EC_I2C_NAK;                  // NAK => abort
 420              		.loc 1 139 0
 421 005c 0623     		movs	r3, #6
 422 005e 07E0     		b	.L23
 423              	.L22:
 132:../Sources/i2c/i2c.c ****     {
 424              		.loc 1 132 0 discriminator 2
 425 0060 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 426 0062 0133     		adds	r3, r3, #1
 427 0064 FB73     		strb	r3, [r7, #15]
 428              	.L20:
 132:../Sources/i2c/i2c.c ****     {
 429              		.loc 1 132 0 is_stmt 0 discriminator 1
 430 0066 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 431 0068 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 432 006a 9A42     		cmp	r2, r3
 433 006c D1D3     		bcc	.L24
 140:../Sources/i2c/i2c.c ****         }
 141:../Sources/i2c/i2c.c ****     }
 142:../Sources/i2c/i2c.c ****     return EC_SUCCESS;
 434              		.loc 1 142 0 is_stmt 1
 435 006e 0023     		movs	r3, #0
 436              	.L23:
 143:../Sources/i2c/i2c.c **** }
 437              		.loc 1 143 0
 438 0070 1846     		mov	r0, r3
 439 0072 1437     		adds	r7, r7, #20
 440              		.cfi_def_cfa_offset 4
 441 0074 BD46     		mov	sp, r7
 442              		.cfi_def_cfa_register 13
 443              		@ sp needed
 444 0076 5DF8047B 		ldr	r7, [sp], #4
 445              		.cfi_restore 7
 446              		.cfi_def_cfa_offset 0
 447 007a 7047     		bx	lr
 448              	.L26:
 449              		.align	2
 450              	.L25:
 451 007c 00600640 		.word	1074159616
 452              		.cfi_endproc
 453              	.LFE128:
 455              		.section	.text.i2cReceiveData,"ax",%progbits
 456              		.align	1
 457              		.global	i2cReceiveData
 458              		.syntax unified
 459              		.thumb
 460              		.thumb_func
 461              		.fpu fpv4-sp-d16
 463              	i2cReceiveData:
 464              	.LFB129:
 144:../Sources/i2c/i2c.c **** 
 145:../Sources/i2c/i2c.c **** /**
 146:../Sources/i2c/i2c.c ****  * Reads data from a I2C-Device. It is assumed that
 147:../Sources/i2c/i2c.c ****  * i2cStart() was successful before.
 148:../Sources/i2c/i2c.c ****  *
 149:../Sources/i2c/i2c.c ****  * This function generates a stop condition at the end!
 150:../Sources/i2c/i2c.c ****  *
 151:../Sources/i2c/i2c.c ****  * @param [out] buf
 152:../Sources/i2c/i2c.c ****  *   the buffer for the receiving data
 153:../Sources/i2c/i2c.c ****  * @param [in] length
 154:../Sources/i2c/i2c.c ****  *   the number of bytes to receive
 155:../Sources/i2c/i2c.c ****  */
 156:../Sources/i2c/i2c.c **** void i2cReceiveData(uint8_t *buf, uint8_t length)
 157:../Sources/i2c/i2c.c **** {
 465              		.loc 1 157 0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 16
 468              		@ frame_needed = 1, uses_anonymous_args = 0
 469              		@ link register save eliminated.
 470 0000 80B4     		push	{r7}
 471              		.cfi_def_cfa_offset 4
 472              		.cfi_offset 7, -4
 473 0002 85B0     		sub	sp, sp, #20
 474              		.cfi_def_cfa_offset 24
 475 0004 00AF     		add	r7, sp, #0
 476              		.cfi_def_cfa_register 7
 477 0006 7860     		str	r0, [r7, #4]
 478 0008 0B46     		mov	r3, r1
 479 000a FB70     		strb	r3, [r7, #3]
 158:../Sources/i2c/i2c.c ****   uint8_t i;
 159:../Sources/i2c/i2c.c ****   I2Cx_C1 &= ~I2C_C1_TX_MASK;               // change to receive mode
 480              		.loc 1 159 0
 481 000c 554A     		ldr	r2, .L37
 482 000e 554B     		ldr	r3, .L37
 483 0010 9B78     		ldrb	r3, [r3, #2]
 484 0012 DBB2     		uxtb	r3, r3
 485 0014 23F01003 		bic	r3, r3, #16
 486 0018 DBB2     		uxtb	r3, r3
 487 001a 9370     		strb	r3, [r2, #2]
 160:../Sources/i2c/i2c.c **** 
 161:../Sources/i2c/i2c.c ****   if (length > 1) {
 488              		.loc 1 161 0
 489 001c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 490 001e 012B     		cmp	r3, #1
 491 0020 6FD9     		bls	.L28
 162:../Sources/i2c/i2c.c ****     I2Cx_C1 &= ~I2C_C1_TXAK_MASK;           // generates ACK's from now on
 492              		.loc 1 162 0
 493 0022 504A     		ldr	r2, .L37
 494 0024 4F4B     		ldr	r3, .L37
 495 0026 9B78     		ldrb	r3, [r3, #2]
 496 0028 DBB2     		uxtb	r3, r3
 497 002a 23F00803 		bic	r3, r3, #8
 498 002e DBB2     		uxtb	r3, r3
 499 0030 9370     		strb	r3, [r2, #2]
 163:../Sources/i2c/i2c.c ****     buf[0] = I2Cx_D;                        // dummy read to start the transmission and to read the
 500              		.loc 1 163 0
 501 0032 4C4B     		ldr	r3, .L37
 502 0034 1B79     		ldrb	r3, [r3, #4]
 503 0036 DAB2     		uxtb	r2, r3
 504 0038 7B68     		ldr	r3, [r7, #4]
 505 003a 1A70     		strb	r2, [r3]
 164:../Sources/i2c/i2c.c ****     while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
 506              		.loc 1 164 0
 507 003c 00BF     		nop
 508              	.L29:
 509              		.loc 1 164 0 is_stmt 0 discriminator 1
 510 003e 494B     		ldr	r3, .L37
 511 0040 DB78     		ldrb	r3, [r3, #3]
 512 0042 DBB2     		uxtb	r3, r3
 513 0044 03F00203 		and	r3, r3, #2
 514 0048 002B     		cmp	r3, #0
 515 004a F8D0     		beq	.L29
 165:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 516              		.loc 1 165 0 is_stmt 1
 517 004c 454A     		ldr	r2, .L37
 518 004e 454B     		ldr	r3, .L37
 519 0050 DB78     		ldrb	r3, [r3, #3]
 520 0052 DBB2     		uxtb	r3, r3
 521 0054 43F00203 		orr	r3, r3, #2
 522 0058 DBB2     		uxtb	r3, r3
 523 005a D370     		strb	r3, [r2, #3]
 166:../Sources/i2c/i2c.c **** 
 167:../Sources/i2c/i2c.c ****     for (i=0; i<length-2; i++) {            // read the bytes in a loop
 524              		.loc 1 167 0
 525 005c 0023     		movs	r3, #0
 526 005e FB73     		strb	r3, [r7, #15]
 527 0060 19E0     		b	.L30
 528              	.L32:
 168:../Sources/i2c/i2c.c ****       buf[i] = I2Cx_D;                      // read the received byte and start a new transmission.
 529              		.loc 1 168 0
 530 0062 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 531 0064 7A68     		ldr	r2, [r7, #4]
 532 0066 1344     		add	r3, r3, r2
 533 0068 3E4A     		ldr	r2, .L37
 534 006a 1279     		ldrb	r2, [r2, #4]
 535 006c D2B2     		uxtb	r2, r2
 536 006e 1A70     		strb	r2, [r3]
 169:../Sources/i2c/i2c.c ****       while (!(I2Cx_S & I2C_S_IICIF_MASK)); // wait for the transfer to complete
 537              		.loc 1 169 0
 538 0070 00BF     		nop
 539              	.L31:
 540              		.loc 1 169 0 is_stmt 0 discriminator 1
 541 0072 3C4B     		ldr	r3, .L37
 542 0074 DB78     		ldrb	r3, [r3, #3]
 543 0076 DBB2     		uxtb	r3, r3
 544 0078 03F00203 		and	r3, r3, #2
 545 007c 002B     		cmp	r3, #0
 546 007e F8D0     		beq	.L31
 170:../Sources/i2c/i2c.c ****       I2Cx_S |= I2C_S_IICIF_MASK;           // clear the interrupt flag
 547              		.loc 1 170 0 is_stmt 1 discriminator 2
 548 0080 384A     		ldr	r2, .L37
 549 0082 384B     		ldr	r3, .L37
 550 0084 DB78     		ldrb	r3, [r3, #3]
 551 0086 DBB2     		uxtb	r3, r3
 552 0088 43F00203 		orr	r3, r3, #2
 553 008c DBB2     		uxtb	r3, r3
 554 008e D370     		strb	r3, [r2, #3]
 167:../Sources/i2c/i2c.c ****       buf[i] = I2Cx_D;                      // read the received byte and start a new transmission.
 555              		.loc 1 167 0 discriminator 2
 556 0090 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 557 0092 0133     		adds	r3, r3, #1
 558 0094 FB73     		strb	r3, [r7, #15]
 559              	.L30:
 167:../Sources/i2c/i2c.c ****       buf[i] = I2Cx_D;                      // read the received byte and start a new transmission.
 560              		.loc 1 167 0 is_stmt 0 discriminator 1
 561 0096 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 562 0098 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 563 009a 023B     		subs	r3, r3, #2
 564 009c 9A42     		cmp	r2, r3
 565 009e E0DB     		blt	.L32
 171:../Sources/i2c/i2c.c ****     }
 172:../Sources/i2c/i2c.c **** 
 173:../Sources/i2c/i2c.c ****     I2Cx_C1 |= I2C_C1_TXAK_MASK;            // Don't send an ACK after the last byte received to ge
 566              		.loc 1 173 0 is_stmt 1
 567 00a0 304A     		ldr	r2, .L37
 568 00a2 304B     		ldr	r3, .L37
 569 00a4 9B78     		ldrb	r3, [r3, #2]
 570 00a6 DBB2     		uxtb	r3, r3
 571 00a8 43F00803 		orr	r3, r3, #8
 572 00ac DBB2     		uxtb	r3, r3
 573 00ae 9370     		strb	r3, [r2, #2]
 174:../Sources/i2c/i2c.c ****     buf[length - 2] = I2Cx_D;               // read the received byte and start a new transmission.
 574              		.loc 1 174 0
 575 00b0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 576 00b2 023B     		subs	r3, r3, #2
 577 00b4 7A68     		ldr	r2, [r7, #4]
 578 00b6 1344     		add	r3, r3, r2
 579 00b8 2A4A     		ldr	r2, .L37
 580 00ba 1279     		ldrb	r2, [r2, #4]
 581 00bc D2B2     		uxtb	r2, r2
 582 00be 1A70     		strb	r2, [r3]
 175:../Sources/i2c/i2c.c ****     while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
 583              		.loc 1 175 0
 584 00c0 00BF     		nop
 585              	.L33:
 586              		.loc 1 175 0 is_stmt 0 discriminator 1
 587 00c2 284B     		ldr	r3, .L37
 588 00c4 DB78     		ldrb	r3, [r3, #3]
 589 00c6 DBB2     		uxtb	r3, r3
 590 00c8 03F00203 		and	r3, r3, #2
 591 00cc 002B     		cmp	r3, #0
 592 00ce F8D0     		beq	.L33
 176:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 593              		.loc 1 176 0 is_stmt 1
 594 00d0 244A     		ldr	r2, .L37
 595 00d2 244B     		ldr	r3, .L37
 596 00d4 DB78     		ldrb	r3, [r3, #3]
 597 00d6 DBB2     		uxtb	r3, r3
 598 00d8 43F00203 		orr	r3, r3, #2
 599 00dc DBB2     		uxtb	r3, r3
 600 00de D370     		strb	r3, [r2, #3]
 177:../Sources/i2c/i2c.c **** 
 178:../Sources/i2c/i2c.c ****     I2Cx_C1 &= ~I2C_C1_MST_MASK;            // generate the stop condition
 601              		.loc 1 178 0
 602 00e0 204A     		ldr	r2, .L37
 603 00e2 204B     		ldr	r3, .L37
 604 00e4 9B78     		ldrb	r3, [r3, #2]
 605 00e6 DBB2     		uxtb	r3, r3
 606 00e8 23F02003 		bic	r3, r3, #32
 607 00ec DBB2     		uxtb	r3, r3
 608 00ee 9370     		strb	r3, [r2, #2]
 179:../Sources/i2c/i2c.c ****     buf[length-1] = I2Cx_D;                 // read the last byte
 609              		.loc 1 179 0
 610 00f0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 611 00f2 013B     		subs	r3, r3, #1
 612 00f4 7A68     		ldr	r2, [r7, #4]
 613 00f6 1344     		add	r3, r3, r2
 614 00f8 1A4A     		ldr	r2, .L37
 615 00fa 1279     		ldrb	r2, [r2, #4]
 616 00fc D2B2     		uxtb	r2, r2
 617 00fe 1A70     		strb	r2, [r3]
 180:../Sources/i2c/i2c.c ****   }
 181:../Sources/i2c/i2c.c ****   else {
 182:../Sources/i2c/i2c.c ****     I2Cx_C1 |= I2C_C1_TXAK_MASK;            // Don't send an ACK after the last byte received to ge
 183:../Sources/i2c/i2c.c ****     buf[0] = I2Cx_D;                        // dummy read to start the last transmission to read th
 184:../Sources/i2c/i2c.c ****     while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
 185:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 186:../Sources/i2c/i2c.c **** 
 187:../Sources/i2c/i2c.c ****     I2Cx_C1 &= ~I2C_C1_MST_MASK;            // generate Stop-Condition
 188:../Sources/i2c/i2c.c ****     buf[0] = I2Cx_D;                        // read last received byte
 189:../Sources/i2c/i2c.c ****   }
 190:../Sources/i2c/i2c.c **** }
 618              		.loc 1 190 0
 619 0100 29E0     		b	.L36
 620              	.L28:
 182:../Sources/i2c/i2c.c ****     buf[0] = I2Cx_D;                        // dummy read to start the last transmission to read th
 621              		.loc 1 182 0
 622 0102 184A     		ldr	r2, .L37
 623 0104 174B     		ldr	r3, .L37
 624 0106 9B78     		ldrb	r3, [r3, #2]
 625 0108 DBB2     		uxtb	r3, r3
 626 010a 43F00803 		orr	r3, r3, #8
 627 010e DBB2     		uxtb	r3, r3
 628 0110 9370     		strb	r3, [r2, #2]
 183:../Sources/i2c/i2c.c ****     while (!(I2Cx_S & I2C_S_IICIF_MASK));   // wait for the transfer to complete
 629              		.loc 1 183 0
 630 0112 144B     		ldr	r3, .L37
 631 0114 1B79     		ldrb	r3, [r3, #4]
 632 0116 DAB2     		uxtb	r2, r3
 633 0118 7B68     		ldr	r3, [r7, #4]
 634 011a 1A70     		strb	r2, [r3]
 184:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 635              		.loc 1 184 0
 636 011c 00BF     		nop
 637              	.L35:
 184:../Sources/i2c/i2c.c ****     I2Cx_S |= I2C_S_IICIF_MASK;             // clear the interrupt flag
 638              		.loc 1 184 0 is_stmt 0 discriminator 1
 639 011e 114B     		ldr	r3, .L37
 640 0120 DB78     		ldrb	r3, [r3, #3]
 641 0122 DBB2     		uxtb	r3, r3
 642 0124 03F00203 		and	r3, r3, #2
 643 0128 002B     		cmp	r3, #0
 644 012a F8D0     		beq	.L35
 185:../Sources/i2c/i2c.c **** 
 645              		.loc 1 185 0 is_stmt 1
 646 012c 0D4A     		ldr	r2, .L37
 647 012e 0D4B     		ldr	r3, .L37
 648 0130 DB78     		ldrb	r3, [r3, #3]
 649 0132 DBB2     		uxtb	r3, r3
 650 0134 43F00203 		orr	r3, r3, #2
 651 0138 DBB2     		uxtb	r3, r3
 652 013a D370     		strb	r3, [r2, #3]
 187:../Sources/i2c/i2c.c ****     buf[0] = I2Cx_D;                        // read last received byte
 653              		.loc 1 187 0
 654 013c 094A     		ldr	r2, .L37
 655 013e 094B     		ldr	r3, .L37
 656 0140 9B78     		ldrb	r3, [r3, #2]
 657 0142 DBB2     		uxtb	r3, r3
 658 0144 23F02003 		bic	r3, r3, #32
 659 0148 DBB2     		uxtb	r3, r3
 660 014a 9370     		strb	r3, [r2, #2]
 188:../Sources/i2c/i2c.c ****   }
 661              		.loc 1 188 0
 662 014c 054B     		ldr	r3, .L37
 663 014e 1B79     		ldrb	r3, [r3, #4]
 664 0150 DAB2     		uxtb	r2, r3
 665 0152 7B68     		ldr	r3, [r7, #4]
 666 0154 1A70     		strb	r2, [r3]
 667              	.L36:
 668              		.loc 1 190 0
 669 0156 00BF     		nop
 670 0158 1437     		adds	r7, r7, #20
 671              		.cfi_def_cfa_offset 4
 672 015a BD46     		mov	sp, r7
 673              		.cfi_def_cfa_register 13
 674              		@ sp needed
 675 015c 5DF8047B 		ldr	r7, [sp], #4
 676              		.cfi_restore 7
 677              		.cfi_def_cfa_offset 0
 678 0160 7047     		bx	lr
 679              	.L38:
 680 0162 00BF     		.align	2
 681              	.L37:
 682 0164 00600640 		.word	1074159616
 683              		.cfi_endproc
 684              	.LFE129:
 686              		.section	.text.i2cStop,"ax",%progbits
 687              		.align	1
 688              		.global	i2cStop
 689              		.syntax unified
 690              		.thumb
 691              		.thumb_func
 692              		.fpu fpv4-sp-d16
 694              	i2cStop:
 695              	.LFB130:
 191:../Sources/i2c/i2c.c **** 
 192:../Sources/i2c/i2c.c **** /**
 193:../Sources/i2c/i2c.c ****  * Generates the stop condition
 194:../Sources/i2c/i2c.c ****  */
 195:../Sources/i2c/i2c.c **** void i2cStop()
 196:../Sources/i2c/i2c.c **** {
 696              		.loc 1 196 0
 697              		.cfi_startproc
 698              		@ args = 0, pretend = 0, frame = 0
 699              		@ frame_needed = 1, uses_anonymous_args = 0
 700              		@ link register save eliminated.
 701 0000 80B4     		push	{r7}
 702              		.cfi_def_cfa_offset 4
 703              		.cfi_offset 7, -4
 704 0002 00AF     		add	r7, sp, #0
 705              		.cfi_def_cfa_register 7
 197:../Sources/i2c/i2c.c ****   I2Cx_C1 &= ~I2C_C1_MST_MASK;              // Generate Stop-Condition
 706              		.loc 1 197 0
 707 0004 0A4A     		ldr	r2, .L40
 708 0006 0A4B     		ldr	r3, .L40
 709 0008 9B78     		ldrb	r3, [r3, #2]
 710 000a DBB2     		uxtb	r3, r3
 711 000c 23F02003 		bic	r3, r3, #32
 712 0010 DBB2     		uxtb	r3, r3
 713 0012 9370     		strb	r3, [r2, #2]
 198:../Sources/i2c/i2c.c ****   I2Cx_S |= I2C_S_IICIF_MASK;               // Clear interrupt flag
 714              		.loc 1 198 0
 715 0014 064A     		ldr	r2, .L40
 716 0016 064B     		ldr	r3, .L40
 717 0018 DB78     		ldrb	r3, [r3, #3]
 718 001a DBB2     		uxtb	r3, r3
 719 001c 43F00203 		orr	r3, r3, #2
 720 0020 DBB2     		uxtb	r3, r3
 721 0022 D370     		strb	r3, [r2, #3]
 199:../Sources/i2c/i2c.c **** }
 722              		.loc 1 199 0
 723 0024 00BF     		nop
 724 0026 BD46     		mov	sp, r7
 725              		.cfi_def_cfa_register 13
 726              		@ sp needed
 727 0028 5DF8047B 		ldr	r7, [sp], #4
 728              		.cfi_restore 7
 729              		.cfi_def_cfa_offset 0
 730 002c 7047     		bx	lr
 731              	.L41:
 732 002e 00BF     		.align	2
 733              	.L40:
 734 0030 00600640 		.word	1074159616
 735              		.cfi_endproc
 736              	.LFE130:
 738              		.section	.text.i2cTest,"ax",%progbits
 739              		.align	1
 740              		.global	i2cTest
 741              		.syntax unified
 742              		.thumb
 743              		.thumb_func
 744              		.fpu fpv4-sp-d16
 746              	i2cTest:
 747              	.LFB131:
 200:../Sources/i2c/i2c.c **** 
 201:../Sources/i2c/i2c.c **** 
 202:../Sources/i2c/i2c.c **** 
 203:../Sources/i2c/i2c.c **** //-------------------------------------------------------------------------------------------------
 204:../Sources/i2c/i2c.c **** // I 2 C   -   C O M P O S I T E   F U N C T I O N S
 205:../Sources/i2c/i2c.c **** //-------------------------------------------------------------------------------------------------
 206:../Sources/i2c/i2c.c **** 
 207:../Sources/i2c/i2c.c **** 
 208:../Sources/i2c/i2c.c **** /**
 209:../Sources/i2c/i2c.c ****  * Checks if a device is on the I2C-Bus and answers with an ACK
 210:../Sources/i2c/i2c.c ****  *
 211:../Sources/i2c/i2c.c ****  * @param [in] adr
 212:../Sources/i2c/i2c.c ****  *   the I2C-Bus address of the device
 213:../Sources/i2c/i2c.c ****  *
 214:../Sources/i2c/i2c.c ****  * @return
 215:../Sources/i2c/i2c.c ****  *   EC_SUCCESS        the slave answered with an ACK
 216:../Sources/i2c/i2c.c ****  *   EC_I2C_NO_ANSWER  no answer from a slave
 217:../Sources/i2c/i2c.c ****  */
 218:../Sources/i2c/i2c.c **** tError i2cTest(uint8_t adr)
 219:../Sources/i2c/i2c.c **** {
 748              		.loc 1 219 0
 749              		.cfi_startproc
 750              		@ args = 0, pretend = 0, frame = 16
 751              		@ frame_needed = 1, uses_anonymous_args = 0
 752 0000 80B5     		push	{r7, lr}
 753              		.cfi_def_cfa_offset 8
 754              		.cfi_offset 7, -8
 755              		.cfi_offset 14, -4
 756 0002 84B0     		sub	sp, sp, #16
 757              		.cfi_def_cfa_offset 24
 758 0004 00AF     		add	r7, sp, #0
 759              		.cfi_def_cfa_register 7
 760 0006 0346     		mov	r3, r0
 761 0008 FB71     		strb	r3, [r7, #7]
 220:../Sources/i2c/i2c.c ****   tError result;
 221:../Sources/i2c/i2c.c ****   result = i2cStart(adr, FALSE);
 762              		.loc 1 221 0
 763 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 764 000c 0021     		movs	r1, #0
 765 000e 1846     		mov	r0, r3
 766 0010 FFF7FEFF 		bl	i2cStart
 767 0014 0346     		mov	r3, r0
 768 0016 FB73     		strb	r3, [r7, #15]
 222:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 769              		.loc 1 222 0
 770 0018 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 771 001a 002B     		cmp	r3, #0
 772 001c 01D0     		beq	.L43
 773              		.loc 1 222 0 is_stmt 0 discriminator 1
 774 001e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 775 0020 02E0     		b	.L44
 776              	.L43:
 223:../Sources/i2c/i2c.c **** 
 224:../Sources/i2c/i2c.c ****   i2cStop();
 777              		.loc 1 224 0 is_stmt 1
 778 0022 FFF7FEFF 		bl	i2cStop
 225:../Sources/i2c/i2c.c ****   return EC_SUCCESS;
 779              		.loc 1 225 0
 780 0026 0023     		movs	r3, #0
 781              	.L44:
 226:../Sources/i2c/i2c.c **** }
 782              		.loc 1 226 0
 783 0028 1846     		mov	r0, r3
 784 002a 1037     		adds	r7, r7, #16
 785              		.cfi_def_cfa_offset 8
 786 002c BD46     		mov	sp, r7
 787              		.cfi_def_cfa_register 13
 788              		@ sp needed
 789 002e 80BD     		pop	{r7, pc}
 790              		.cfi_endproc
 791              	.LFE131:
 793              		.section	.text.i2cReadCmdData,"ax",%progbits
 794              		.align	1
 795              		.global	i2cReadCmdData
 796              		.syntax unified
 797              		.thumb
 798              		.thumb_func
 799              		.fpu fpv4-sp-d16
 801              	i2cReadCmdData:
 802              	.LFB132:
 227:../Sources/i2c/i2c.c **** 
 228:../Sources/i2c/i2c.c **** 
 229:../Sources/i2c/i2c.c ****  /**
 230:../Sources/i2c/i2c.c ****  * Reads data from an I2C-Device with an additional command byte
 231:../Sources/i2c/i2c.c ****  * which is send before
 232:../Sources/i2c/i2c.c ****  *
 233:../Sources/i2c/i2c.c ****  * @param [in] adr
 234:../Sources/i2c/i2c.c ****  *   the I2C-Bus address of the device
 235:../Sources/i2c/i2c.c ****  * @param [in] cmd
 236:../Sources/i2c/i2c.c ****  *   the command byte or register byte to send before
 237:../Sources/i2c/i2c.c ****  * @param [out] data
 238:../Sources/i2c/i2c.c ****  *   the data to send
 239:../Sources/i2c/i2c.c ****  * @param [in] length
 240:../Sources/i2c/i2c.c ****  *   the number of bytes to send
 241:../Sources/i2c/i2c.c ****  *
 242:../Sources/i2c/i2c.c ****  * @return
 243:../Sources/i2c/i2c.c ****  *   EC_SUCCESS       the slave answered with an ACK
 244:../Sources/i2c/i2c.c ****  *   EC_I2C_NAK       if the slave answered with a NAK
 245:../Sources/i2c/i2c.c ****  *   EC_I2C_NO_ANSWER no answer from the slave
 246:../Sources/i2c/i2c.c ****  */
 247:../Sources/i2c/i2c.c **** tError i2cReadCmdData(uint8_t adr, uint8_t cmd, uint8_t *data, uint8_t length)
 248:../Sources/i2c/i2c.c **** {
 803              		.loc 1 248 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 16
 806              		@ frame_needed = 1, uses_anonymous_args = 0
 807 0000 80B5     		push	{r7, lr}
 808              		.cfi_def_cfa_offset 8
 809              		.cfi_offset 7, -8
 810              		.cfi_offset 14, -4
 811 0002 84B0     		sub	sp, sp, #16
 812              		.cfi_def_cfa_offset 24
 813 0004 00AF     		add	r7, sp, #0
 814              		.cfi_def_cfa_register 7
 815 0006 3A60     		str	r2, [r7]
 816 0008 1A46     		mov	r2, r3
 817 000a 0346     		mov	r3, r0
 818 000c FB71     		strb	r3, [r7, #7]
 819 000e 0B46     		mov	r3, r1
 820 0010 BB71     		strb	r3, [r7, #6]
 821 0012 1346     		mov	r3, r2
 822 0014 7B71     		strb	r3, [r7, #5]
 249:../Sources/i2c/i2c.c ****   tError result;
 250:../Sources/i2c/i2c.c ****   result = i2cStart(adr, FALSE);            // send I2C-Address
 823              		.loc 1 250 0
 824 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 825 0018 0021     		movs	r1, #0
 826 001a 1846     		mov	r0, r3
 827 001c FFF7FEFF 		bl	i2cStart
 828 0020 0346     		mov	r3, r0
 829 0022 FB73     		strb	r3, [r7, #15]
 251:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 830              		.loc 1 251 0
 831 0024 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 832 0026 002B     		cmp	r3, #0
 833 0028 01D0     		beq	.L46
 834              		.loc 1 251 0 is_stmt 0 discriminator 1
 835 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 836 002c 1DE0     		b	.L47
 837              	.L46:
 252:../Sources/i2c/i2c.c **** 
 253:../Sources/i2c/i2c.c ****   result = i2cSendData(&cmd, 1);            // send command byte
 838              		.loc 1 253 0 is_stmt 1
 839 002e BB1D     		adds	r3, r7, #6
 840 0030 0121     		movs	r1, #1
 841 0032 1846     		mov	r0, r3
 842 0034 FFF7FEFF 		bl	i2cSendData
 843 0038 0346     		mov	r3, r0
 844 003a FB73     		strb	r3, [r7, #15]
 254:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 845              		.loc 1 254 0
 846 003c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 847 003e 002B     		cmp	r3, #0
 848 0040 01D0     		beq	.L48
 849              		.loc 1 254 0 is_stmt 0 discriminator 1
 850 0042 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 851 0044 11E0     		b	.L47
 852              	.L48:
 255:../Sources/i2c/i2c.c **** 
 256:../Sources/i2c/i2c.c ****   result = i2cRepeatedStart(adr, TRUE);     // repeated start to change the direction from write to
 853              		.loc 1 256 0 is_stmt 1
 854 0046 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 855 0048 0121     		movs	r1, #1
 856 004a 1846     		mov	r0, r3
 857 004c FFF7FEFF 		bl	i2cRepeatedStart
 858 0050 0346     		mov	r3, r0
 859 0052 FB73     		strb	r3, [r7, #15]
 257:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 860              		.loc 1 257 0
 861 0054 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 862 0056 002B     		cmp	r3, #0
 863 0058 01D0     		beq	.L49
 864              		.loc 1 257 0 is_stmt 0 discriminator 1
 865 005a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 866 005c 05E0     		b	.L47
 867              	.L49:
 258:../Sources/i2c/i2c.c **** 
 259:../Sources/i2c/i2c.c ****   i2cReceiveData(data, length);             // read the data & generate the stop condition
 868              		.loc 1 259 0 is_stmt 1
 869 005e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 870 0060 1946     		mov	r1, r3
 871 0062 3868     		ldr	r0, [r7]
 872 0064 FFF7FEFF 		bl	i2cReceiveData
 260:../Sources/i2c/i2c.c ****   return EC_SUCCESS;
 873              		.loc 1 260 0
 874 0068 0023     		movs	r3, #0
 875              	.L47:
 261:../Sources/i2c/i2c.c **** }
 876              		.loc 1 261 0
 877 006a 1846     		mov	r0, r3
 878 006c 1037     		adds	r7, r7, #16
 879              		.cfi_def_cfa_offset 8
 880 006e BD46     		mov	sp, r7
 881              		.cfi_def_cfa_register 13
 882              		@ sp needed
 883 0070 80BD     		pop	{r7, pc}
 884              		.cfi_endproc
 885              	.LFE132:
 887              		.section	.text.i2cWriteCmdData,"ax",%progbits
 888              		.align	1
 889              		.global	i2cWriteCmdData
 890              		.syntax unified
 891              		.thumb
 892              		.thumb_func
 893              		.fpu fpv4-sp-d16
 895              	i2cWriteCmdData:
 896              	.LFB133:
 262:../Sources/i2c/i2c.c **** 
 263:../Sources/i2c/i2c.c **** /**
 264:../Sources/i2c/i2c.c ****  * Writes data to an I2C-Device with an additional command byte
 265:../Sources/i2c/i2c.c ****  * which is send before
 266:../Sources/i2c/i2c.c ****  *
 267:../Sources/i2c/i2c.c ****  * @param [in] adr
 268:../Sources/i2c/i2c.c ****  *   the I2C-Bus address of the device
 269:../Sources/i2c/i2c.c ****  * @param [in] cmd
 270:../Sources/i2c/i2c.c ****  *   the command byte or register byte to send before
 271:../Sources/i2c/i2c.c ****  * @param [in] data
 272:../Sources/i2c/i2c.c ****  *   the buffer for the receiving data
 273:../Sources/i2c/i2c.c ****  * @param [in] length
 274:../Sources/i2c/i2c.c ****  *   the number of bytes to receive
 275:../Sources/i2c/i2c.c ****  * @return
 276:../Sources/i2c/i2c.c ****  *   EC_SUCCESS       the slave answered with an ACK
 277:../Sources/i2c/i2c.c ****  *   EC_I2C_NAK       if the slave answered with a NAK
 278:../Sources/i2c/i2c.c ****  *   EC_I2C_NO_ANSWER no answer from the slave
 279:../Sources/i2c/i2c.c ****  */
 280:../Sources/i2c/i2c.c **** tError i2cWriteCmdData(uint8_t adr, uint8_t cmd, uint8_t *data, uint8_t length)
 281:../Sources/i2c/i2c.c **** {
 897              		.loc 1 281 0
 898              		.cfi_startproc
 899              		@ args = 0, pretend = 0, frame = 16
 900              		@ frame_needed = 1, uses_anonymous_args = 0
 901 0000 80B5     		push	{r7, lr}
 902              		.cfi_def_cfa_offset 8
 903              		.cfi_offset 7, -8
 904              		.cfi_offset 14, -4
 905 0002 84B0     		sub	sp, sp, #16
 906              		.cfi_def_cfa_offset 24
 907 0004 00AF     		add	r7, sp, #0
 908              		.cfi_def_cfa_register 7
 909 0006 3A60     		str	r2, [r7]
 910 0008 1A46     		mov	r2, r3
 911 000a 0346     		mov	r3, r0
 912 000c FB71     		strb	r3, [r7, #7]
 913 000e 0B46     		mov	r3, r1
 914 0010 BB71     		strb	r3, [r7, #6]
 915 0012 1346     		mov	r3, r2
 916 0014 7B71     		strb	r3, [r7, #5]
 282:../Sources/i2c/i2c.c ****   tError result;
 283:../Sources/i2c/i2c.c ****   result = i2cStart(adr, FALSE);            // send I2C-Address
 917              		.loc 1 283 0
 918 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 919 0018 0021     		movs	r1, #0
 920 001a 1846     		mov	r0, r3
 921 001c FFF7FEFF 		bl	i2cStart
 922 0020 0346     		mov	r3, r0
 923 0022 FB73     		strb	r3, [r7, #15]
 284:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 924              		.loc 1 284 0
 925 0024 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 926 0026 002B     		cmp	r3, #0
 927 0028 01D0     		beq	.L51
 928              		.loc 1 284 0 is_stmt 0 discriminator 1
 929 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 930 002c 1AE0     		b	.L52
 931              	.L51:
 285:../Sources/i2c/i2c.c **** 
 286:../Sources/i2c/i2c.c ****   result = i2cSendData(&cmd, 1);            // send command byte
 932              		.loc 1 286 0 is_stmt 1
 933 002e BB1D     		adds	r3, r7, #6
 934 0030 0121     		movs	r1, #1
 935 0032 1846     		mov	r0, r3
 936 0034 FFF7FEFF 		bl	i2cSendData
 937 0038 0346     		mov	r3, r0
 938 003a FB73     		strb	r3, [r7, #15]
 287:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 939              		.loc 1 287 0
 940 003c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 941 003e 002B     		cmp	r3, #0
 942 0040 01D0     		beq	.L53
 943              		.loc 1 287 0 is_stmt 0 discriminator 1
 944 0042 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 945 0044 0EE0     		b	.L52
 946              	.L53:
 288:../Sources/i2c/i2c.c **** 
 289:../Sources/i2c/i2c.c ****   result = i2cSendData(data, length);       // send data
 947              		.loc 1 289 0 is_stmt 1
 948 0046 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 949 0048 1946     		mov	r1, r3
 950 004a 3868     		ldr	r0, [r7]
 951 004c FFF7FEFF 		bl	i2cSendData
 952 0050 0346     		mov	r3, r0
 953 0052 FB73     		strb	r3, [r7, #15]
 290:../Sources/i2c/i2c.c ****   if (result != EC_SUCCESS) return result;
 954              		.loc 1 290 0
 955 0054 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 956 0056 002B     		cmp	r3, #0
 957 0058 01D0     		beq	.L54
 958              		.loc 1 290 0 is_stmt 0 discriminator 1
 959 005a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 960 005c 02E0     		b	.L52
 961              	.L54:
 291:../Sources/i2c/i2c.c **** 
 292:../Sources/i2c/i2c.c ****   i2cStop();                                // generate stop condition
 962              		.loc 1 292 0 is_stmt 1
 963 005e FFF7FEFF 		bl	i2cStop
 293:../Sources/i2c/i2c.c ****   return EC_SUCCESS;
 964              		.loc 1 293 0
 965 0062 0023     		movs	r3, #0
 966              	.L52:
 294:../Sources/i2c/i2c.c **** }
 967              		.loc 1 294 0
 968 0064 1846     		mov	r0, r3
 969 0066 1037     		adds	r7, r7, #16
 970              		.cfi_def_cfa_offset 8
 971 0068 BD46     		mov	sp, r7
 972              		.cfi_def_cfa_register 13
 973              		@ sp needed
 974 006a 80BD     		pop	{r7, pc}
 975              		.cfi_endproc
 976              	.LFE133:
 978              		.section	.text.i2cInit,"ax",%progbits
 979              		.align	1
 980              		.global	i2cInit
 981              		.syntax unified
 982              		.thumb
 983              		.thumb_func
 984              		.fpu fpv4-sp-d16
 986              	i2cInit:
 987              	.LFB134:
 295:../Sources/i2c/i2c.c **** 
 296:../Sources/i2c/i2c.c **** 
 297:../Sources/i2c/i2c.c **** /**
 298:../Sources/i2c/i2c.c ****  * Initializes the I2C-Bus I2C0 to ~400kBit/s
 299:../Sources/i2c/i2c.c ****  */
 300:../Sources/i2c/i2c.c **** void i2cInit(void)
 301:../Sources/i2c/i2c.c **** {
 988              		.loc 1 301 0
 989              		.cfi_startproc
 990              		@ args = 0, pretend = 0, frame = 0
 991              		@ frame_needed = 1, uses_anonymous_args = 0
 992              		@ link register save eliminated.
 993 0000 80B4     		push	{r7}
 994              		.cfi_def_cfa_offset 4
 995              		.cfi_offset 7, -4
 996 0002 00AF     		add	r7, sp, #0
 997              		.cfi_def_cfa_register 7
 302:../Sources/i2c/i2c.c ****   // _todo ML#10.01 configure clock gating for i2c bus
 303:../Sources/i2c/i2c.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;
 998              		.loc 1 303 0
 999 0004 1149     		ldr	r1, .L56
 1000 0006 114B     		ldr	r3, .L56
 1001 0008 03F58153 		add	r3, r3, #4128
 1002 000c 1433     		adds	r3, r3, #20
 1003 000e 1B68     		ldr	r3, [r3]
 1004 0010 43F04002 		orr	r2, r3, #64
 1005 0014 01F58153 		add	r3, r1, #4128
 1006 0018 1433     		adds	r3, r3, #20
 1007 001a 1A60     		str	r2, [r3]
 304:../Sources/i2c/i2c.c **** 
 305:../Sources/i2c/i2c.c ****   // _todo ML#10.02 configure MUX for SCL & SDA
 306:../Sources/i2c/i2c.c **** //  PORTE_PCR24 = PORT_PCR_MUX(5) | PORT_PCR_ODE(1);
 307:../Sources/i2c/i2c.c **** //  PORTE_PCR25 = PORT_PCR_MUX(5) | PORT_PCR_ODE(1);
 308:../Sources/i2c/i2c.c **** 
 309:../Sources/i2c/i2c.c **** 
 310:../Sources/i2c/i2c.c ****   PORTB_PCR0 = PORT_PCR_MUX(2) | PORT_PCR_ODE(1);
 1008              		.loc 1 310 0
 1009 001c 0C4B     		ldr	r3, .L56+4
 1010 001e 4FF40872 		mov	r2, #544
 1011 0022 1A60     		str	r2, [r3]
 311:../Sources/i2c/i2c.c ****   PORTB_PCR1 = PORT_PCR_MUX(2) | PORT_PCR_ODE(1);
 1012              		.loc 1 311 0
 1013 0024 0A4B     		ldr	r3, .L56+4
 1014 0026 4FF40872 		mov	r2, #544
 1015 002a 5A60     		str	r2, [r3, #4]
 312:../Sources/i2c/i2c.c ****   // _todo ML#10.03 configure i2c clock (frequency divider register) to 400 kHz
 313:../Sources/i2c/i2c.c ****   I2Cx_F = 0x1D;  // 60 MHz/(1*160) = 375kHz => MULT=0, ICR=1D
 1016              		.loc 1 313 0
 1017 002c 094B     		ldr	r3, .L56+8
 1018 002e 1D22     		movs	r2, #29
 1019 0030 5A70     		strb	r2, [r3, #1]
 314:../Sources/i2c/i2c.c **** 
 315:../Sources/i2c/i2c.c ****   // _todo ML#10.04 enable i2c bus
 316:../Sources/i2c/i2c.c ****   I2Cx_C1 |= I2C_C1_IICEN_MASK;
 1020              		.loc 1 316 0
 1021 0032 084A     		ldr	r2, .L56+8
 1022 0034 074B     		ldr	r3, .L56+8
 1023 0036 9B78     		ldrb	r3, [r3, #2]
 1024 0038 DBB2     		uxtb	r3, r3
 1025 003a 63F07F03 		orn	r3, r3, #127
 1026 003e DBB2     		uxtb	r3, r3
 1027 0040 9370     		strb	r3, [r2, #2]
 317:../Sources/i2c/i2c.c **** }
 1028              		.loc 1 317 0
 1029 0042 00BF     		nop
 1030 0044 BD46     		mov	sp, r7
 1031              		.cfi_def_cfa_register 13
 1032              		@ sp needed
 1033 0046 5DF8047B 		ldr	r7, [sp], #4
 1034              		.cfi_restore 7
 1035              		.cfi_def_cfa_offset 0
 1036 004a 7047     		bx	lr
 1037              	.L57:
 1038              		.align	2
 1039              	.L56:
 1040 004c 00700440 		.word	1074032640
 1041 0050 00A00440 		.word	1074044928
 1042 0054 00600640 		.word	1074159616
 1043              		.cfi_endproc
 1044              	.LFE134:
 1046              		.text
 1047              	.Letext0:
 1048              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 1049              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 1050              		.file 4 "../Includes/core_cm4.h"
 1051              		.file 5 "../Includes/system_MK22F51212.h"
 1052              		.file 6 "../Includes/MK22F51212.h"
 1053              		.file 7 "../Includes/platform.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2c.c
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:18     .text.i2cStart:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:25     .text.i2cStart:00000000 i2cStart
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:147    .text.i2cStart:000000b8 $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:152    .text.i2cRepeatedStart:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:159    .text.i2cRepeatedStart:00000000 i2cRepeatedStart
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:254    .text.i2cRepeatedStart:00000088 $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:259    .text.i2cReceiveLastByte:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:266    .text.i2cReceiveLastByte:00000000 i2cReceiveLastByte
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:346    .text.i2cReceiveLastByte:00000070 $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:351    .text.i2cSendData:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:358    .text.i2cSendData:00000000 i2cSendData
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:451    .text.i2cSendData:0000007c $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:456    .text.i2cReceiveData:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:463    .text.i2cReceiveData:00000000 i2cReceiveData
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:682    .text.i2cReceiveData:00000164 $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:687    .text.i2cStop:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:694    .text.i2cStop:00000000 i2cStop
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:734    .text.i2cStop:00000030 $d
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:739    .text.i2cTest:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:746    .text.i2cTest:00000000 i2cTest
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:794    .text.i2cReadCmdData:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:801    .text.i2cReadCmdData:00000000 i2cReadCmdData
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:888    .text.i2cWriteCmdData:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:895    .text.i2cWriteCmdData:00000000 i2cWriteCmdData
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:979    .text.i2cInit:00000000 $t
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:986    .text.i2cInit:00000000 i2cInit
C:\Users\Blub\AppData\Local\Temp\ccHNV5Ex.s:1040   .text.i2cInit:0000004c $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.a6d4f739a788c67292a3ea0a48d10bd5
                           .group:00000000 wm4.MK22F51212.h.96.792c303daa596f91c029224edd7c60aa
                           .group:00000000 wm4._newlib_version.h.4.3572908597b70d672d181fc7fc501c19
                           .group:00000000 wm4.features.h.33.cf97d4c9a045ebab6d282f6356e11363
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.cce27fed8484c08a33f522034c30d2b5
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.MK22F51212.h.109.eeee73bf5f54e3f06177795004b95e22
                           .group:00000000 wm4.core_cm4.h.43.f75e2f71b2e33f7a3db429cd8b0cae9e
                           .group:00000000 wm4.core_cmInstr.h.39.addda81f1f3453ba31dd54fc5b6fcee8
                           .group:00000000 wm4.core_cmSimd.h.43.c355993beb49ccd10586af5b1cfe5aee
                           .group:00000000 wm4.core_cm4.h.201.a59e218d30e39d114c8962bbad645c74
                           .group:00000000 wm4.system_MK22F51212.h.94.09b5fd63c227fb82ca8c370fba9e2334
                           .group:00000000 wm4.MK22F51212.h.369.5a9c5aa32d240e03ff494f1c769cfadf
                           .group:00000000 wm4.platform.h.20.50ac36c902b95111cd960a53a2ea1ddf

NO UNDEFINED SYMBOLS
